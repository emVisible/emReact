
## Task && Question
- 基于实现的最简版MiniReact, 将js变为jsx——使用JSX
- 基于递归的VNode创建的问题? 出现的原因?
  - 在VNode节点层次很深的时候, 算法时间会过长, 导致页面卡顿
    - 当 VNode 节点层次很深时，递归处理可能导致算法的时间复杂度增加，因为每一层递归都需要进行一些操作，如创建节点、处理属性等。
    - 当节点嵌套层次很深时，递归可能会导致堆栈溢出。每一层递归都需要在调用栈上分配一帧，而调用栈的深度是有限的。大量嵌套的节点会导致递归深度增加，最终可能触发堆栈溢出错误。
  - 耗时长, 性能低
    - 频繁的 DOM 操作和深层递归, 会出现重复创建和销毁： 递归过程中，每次创建一个节点，然后递归处理其子节点。这样的递归可能导致大量的节点创建和销毁操作，而这些操作本身是具有一定开销的。可能会增加浏览器的重绘和重排成本。
  - 出现的原因: 在创建的时候是直接操作DOM, 而直接操作DOM的性能开销是很大的。无优化手段。
    - 这一点需要注意一下。实际上，React 中的 Virtual DOM 机制是为了优化直接操作实际 DOM 的性能开销而引入的。通过虚拟 DOM，React 可以在内存中构建整个节点树，然后一次性更新实际 DOM，减少了直接操作 DOM 的频率，从而提高了性能。
- 优化策略:
  - 批量处理： 减少实际的 DOM 操作次数，例如通过文档片段（DocumentFragment）进行批量操作。而不是每次创建节点都立即进行 DOM 操作，可以先在内存中构建节点树，然后一次性添加到 DOM 中。
  - 使用 Key： 在进行递归时，使用唯一的 Key 可以帮助 React 更有效地比较新旧节点，从而减少 DOM 操作。这有助于确保只有需要更新的节点进行了操作。
  - 虚拟 DOM Diff 算法： 使用更高效的虚拟 DOM Diff 算法来比较新旧节点，找出需要更新的部分，减少不必要的操作。
  - 内存优化： 考虑节点的缓存、复用等优化策略，以减少不必要的对象创建和销毁。

## Note
### JSX的转换
浏览器并不认识JSX, 需要借助第三方工具将JSX转为JS
- vite
- webpack
- babel
使用vite可以无需配置的情况下将js转为jsx

### JSX的本质
jsx本质上就是通过VNode的createElement创建的节点, 将其封装为jsx的格式, 通过语法解析调用
```js
JSX（JavaScript XML）是一种语法糖，它提供了一种更直观、更易读的方式来描述虚拟 DOM 结构。
在 React 应用中，JSX 元素实际上会被编译为对 React.createElement 函数的调用，从而创建虚拟节点（VNode）。
```
jsx的语法糖会隐式调用通过import导入的React默认导出对象的createElement()方法,
所以在intoJSX文件夹引入的core中修改React.js的createElement()或者createTextNode()的代码都在使用jsx语法糖的地方显现,
比如log一条信息, 那么jsx调用了多少次, 就会相应的打印多少次

