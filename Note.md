# MiniReact, 实现基本的React操作.
---
## 1——动态创建VDOM && VNode, 实现页面的动态渲染
    - VDOM是基于Js对象对DOM进行抽象描述, 最后根据React自身协调渲染, 来达成从抽象到具体的过程。
    - VNode是VDOM的子集, 是其中的一部分, 同样是基于JS对象来进行有选择地创建, 最后添加到VDOM上

## 2——添加JSX
- 基于实现的最简版MiniReact, 将js变为jsx——使用JSX
- 基于递归的VNode创建的问题? 出现的原因?
  - 在VNode节点层次很深的时候, 算法时间会过长, 导致页面卡顿
    - 在当前的render函数中, 由于Js本身的单线程, 加上函数为同步阻塞执行, 当运算量提高就一定会造成卡顿
    - 当 VNode 节点层次很深时，递归处理可能导致算法的时间复杂度增加，因为每一层递归都需要进行一些操作，如创建节点、处理属性等。
    - 递归可能会导致堆栈溢出。每一层递归都需要在调用栈上分配一帧，而调用栈的深度是有限的。大量嵌套的节点会导致递归深度增加，最终可能触发堆栈溢出错误。
  - 耗时长, 性能低
    - 频繁的 DOM 操作和深层递归, 会出现重复创建和销毁： 递归过程中，每次创建一个节点，然后递归处理其子节点。这样的递归可能导致大量的节点创建和销毁操作，而这些操作本身是具有一定开销的。可能会增加浏览器的重绘和重排成本。
  - 出现的原因: 在创建的时候是直接操作DOM, 而直接操作DOM的性能开销是很大的。无优化手段。
    - 这一点需要注意一下。实际上，React 中的 Virtual DOM 机制是为了优化直接操作实际 DOM 的性能开销而引入的。通过虚拟 DOM，React 可以在内存中构建整个节点树，然后一次性更新实际 DOM，减少了直接操作 DOM 的频率，从而提高了性能。
- 优化策略:
  - 批量处理： 减少实际的 DOM 操作次数，例如通过文档片段（DocumentFragment）进行批量操作。而不是每次创建节点都立即进行 DOM 操作，可以先在内存中构建节点树，然后一次性添加到 DOM 中。
  - 使用 Key： 在进行递归时，使用唯一的 Key 可以帮助 React 更有效地比较新旧节点，从而减少 DOM 操作。这有助于确保只有需要更新的节点进行了操作。
  - 虚拟 DOM Diff 算法： 使用更高效的虚拟 DOM Diff 算法来比较新旧节点，找出需要更新的部分，减少不必要的操作。
  - 内存优化： 考虑节点的缓存、复用等优化策略，以减少不必要的对象创建和销毁。

### JSX的转换
浏览器并不认识JSX, 需要借助第三方工具将JSX转为JS
- vite
- webpack
- babel
使用vite可以无需配置的情况下将js转为jsx

### JSX的本质
jsx本质上就是通过VNode的createElement创建的节点, 将其封装为jsx的格式, 通过语法解析调用
```js
JSX（JavaScript XML）是一种语法糖，它提供了一种更直观、更易读的方式来描述虚拟 DOM 结构。
在 React 应用中，JSX 元素实际上会被编译为对 React.createElement 函数的调用，从而创建虚拟节点（VNode）。
```
jsx的语法糖会隐式调用通过import导入的React默认导出对象的createElement()方法,
所以在intoJSX文件夹引入的core中修改React.js的createElement()或者createTextNode()的代码都在使用jsx语法糖的地方显现,
比如log一条信息, 那么jsx调用了多少次, 就会相应的打印多少次

## 3——任务调度器基础
- 实现任务调度器
  - 用于解决DOM树规模增加时渲染的卡顿
  - 基本思路: 将大任务拆分为多个task
  - 实现: 采用requestIdleCallback
```js
  利用分治的思想, 将DOM树的渲染拆分为多个子任务, 子任务负责渲染部分的DOM树
  具体每次一个task中实现最少一个DOM渲染, 然后进行判断是否还有剩余时间, 如有, 则继续渲染
  数据结构采用链表可以更加方便和适宜地解决问题, 因为DOM是有序的, 子任务必须保证顺序, 而链表的特性可以满足这几点
  对于DOM树, 采用深度优先遍历, 将返回结果生成为链表
    方法一:
      先将DOM全部遍历, 再处理链表
    方法二:
      一边遍历DOM, 一边建立链表

```

## 4——实现简单的fiber架构
- 实现基本的任务调度器
- 数据结构: 链表
- 算法: DOM遍历和链表建立同时进行

问题: requestIdleCallback 是一种在浏览器的空闲时段执行任务的机制，但它并不保证任务会在固定的时间内完成，也可能会因为时间片连续不足而造成渲染中途的延迟。这可能导致用户感知到的卡顿或延迟。reqeustIdleCallback()的运行时间不确定, 可能会因为时间片连续不足造成渲染中途的延迟, 如何解决?
- 任务拆分： 将大任务拆分成小任务，每个小任务耗时较短。这样可以确保在每个空闲时间片内都能完成一部分工作，提高渲染的连续性。这也是 Fiber 架构的一种核心思想。
- 优先级调整： 在任务拆分的基础上，为任务设置不同的优先级。确保高优先级任务先执行，提高用户感知的流畅度。React 中的 Scheduler 就采用了这种策略。
- 使用 Web Workers： 将一些计算密集型或耗时较长的任务放到 Web Workers 中执行，以保持主线程的空闲状态。这样可以提高整体性能，避免主线程被占用过久。
- 性能监控和调整： 使用浏览器开发者工具中的性能监控工具，分析任务执行的时间分布，找出耗时较长的任务，并进行优化。

### Fiber架构
定义: Fiber架构是React 中用于实现协调更新的一种算法和数据结构
目的: Fiber 架构的引入是为了解决 React 在处理大型应用时可能出现的性能瓶颈和阻塞
作用: 使得 React 能够更好地处理复杂的渲染、布局和动画, 并保持较高的性能
主要概念:
- Fiber 节点： 在 Fiber 架构中，每个 React 元素都对应一个 Fiber 节点。这些节点构成了一个虚拟的树结构，称为 Fiber 树。每个 Fiber 节点都包含有关元素的信息，如类型、props、状态等。
- 工作单元： 在 Fiber 架构中，任务被分解为可中断的小单元，称为工作单元。这些工作单元可以在浏览器的空闲时段执行，以提高响应性和用户体验。
- 调度器： Fiber 架构引入了调度器，负责决定在何时执行工作单元。调度器使用优先级来确定哪些工作单元应该首先执行。这样可以确保高优先级的任务优先执行，提高用户感知的流畅度。
- 协调器： 协调器是 Fiber 架构的核心部分，负责协调更新过程。它能够判断哪些部分需要更新，生成新的 Fiber 树，并将更新推送到渲染阶段。
- 渲染器： 渲染器负责将协调器生成的 Fiber 树转换为实际的 DOM
- 双缓存技术： Fiber 架构采用了一种双缓存技术，通过交替使用两个 Fiber 树，来实现无阻塞的渲染。在每次更新时，都会生成一个新的 Fiber 树，然后将新的 Fiber 树与上一次渲染使用的 Fiber 树进行比较，以确定哪些部分需要更新。
- 中断与恢复： Fiber 架构支持任务的中断与恢复，即任务可以在执行过程中被中断，然后在下一个空闲时段继续执行。这有助于避免长时间的任务阻塞主线程。